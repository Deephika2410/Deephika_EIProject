package exporters;

import models.Task;
import models.PriorityLevel;
import utils.Logger;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Interface for schedule export functionality
 * Follows SOLID principles with strategy pattern for different export formats
 */
public interface ScheduleExporter {
    
    /**
     * Exports the schedule to a file
     * @param tasks List of tasks to export
     * @param fileName Output file name
     * @throws IOException if export fails
     */
    void exportSchedule(List<Task> tasks, String fileName) throws IOException;
    
    /**
     * Gets the file extension for this exporter
     * @return File extension (e.g., ".txt", ".csv")
     */
    String getFileExtension();
    
    /**
     * Gets the format name
     * @return Format name (e.g., "Plain Text", "CSV")
     */
    String getFormatName();
}

/**
 * Text file exporter implementation
 * Exports schedule in human-readable text format
 */
class TextScheduleExporter implements ScheduleExporter {
    
    private static final DateTimeFormatter TIMESTAMP_FORMAT = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    @Override
    public void exportSchedule(List<Task> tasks, String fileName) throws IOException {
        if (tasks == null) {
            throw new IllegalArgumentException("Task list cannot be null");
        }
        
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty");
        }
        
        String fullFileName = fileName.endsWith(getFileExtension()) ? 
                            fileName : fileName + getFileExtension();
        
        try (PrintWriter writer = new PrintWriter(new FileWriter(fullFileName))) {
            writeHeader(writer);
            writeTasks(writer, tasks);
            writeFooter(writer);
        } catch (IOException e) {
            throw e;
        }
    }
    
    @Override
    public String getFileExtension() {
        return ".txt";
    }
    
    @Override
    public String getFormatName() {
        return "Plain Text";
    }
    
    private void writeHeader(PrintWriter writer) {
        writer.println("=".repeat(80));
        writer.println("ASTRONAUT DAILY SCHEDULE");
        writer.println("Generated: " + LocalDateTime.now().format(TIMESTAMP_FORMAT));
        writer.println("=".repeat(80));
        writer.println();
    }
    
    private void writeTasks(PrintWriter writer, List<Task> tasks) {
        if (tasks.isEmpty()) {
            writer.println("No tasks scheduled.");
            return;
        }
        
        writer.println(String.format("Total Tasks: %d", tasks.size()));
        writer.println("-".repeat(80));
        writer.println();
        
        // Sort tasks by start time
        tasks.stream()
            .sorted((t1, t2) -> t1.getStartTime().compareTo(t2.getStartTime()))
            .forEach(task -> writeTask(writer, task));
    }
    
    private void writeTask(PrintWriter writer, Task task) {
        String status = task.isCompleted() ? "[COMPLETED]" : "[PENDING]";
        
        writer.println(String.format("Task: %s", task.getDescription()));
        writer.println(String.format("Time: %s - %s", 
                      task.getFormattedStartTime(), task.getFormattedEndTime()));
        writer.println(String.format("Duration: %d minutes", task.getDurationMinutes()));
        writer.println(String.format("Priority: %s", task.getPriorityLevel().getDisplayName()));
        writer.println(String.format("Status: %s", status));
        writer.println(String.format("ID: %s", task.getId()));
        writer.println("-".repeat(40));
    }
    
    private void writeFooter(PrintWriter writer) {
        writer.println();
        writer.println("=".repeat(80));
        writer.println("End of Schedule");
        writer.println("Generated by Astronaut Daily Schedule Organizer");
        writer.println("=".repeat(80));
    }
}

/**
 * CSV file exporter implementation
 * Exports schedule in structured tabular CSV format for spreadsheet applications
 */
class CsvScheduleExporter implements ScheduleExporter {
    
    private static final String CSV_SEPARATOR = ",";
    private static final String CSV_QUOTE = "\"";
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
    
    @Override
    public void exportSchedule(List<Task> tasks, String fileName) throws IOException {
        if (tasks == null) {
            throw new IllegalArgumentException("Task list cannot be null");
        }
        
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty");
        }
        
        String fullFileName = fileName.endsWith(getFileExtension()) ? 
                            fileName : fileName + getFileExtension();
        
        try (PrintWriter writer = new PrintWriter(new FileWriter(fullFileName))) {
            writeScheduleHeader(writer, tasks);
            writeTableHeaders(writer);
            writeScheduleData(writer, tasks);
            writeScheduleSummary(writer, tasks);
        } catch (IOException e) {
            throw e;
        }
    }
    
    @Override
    public String getFileExtension() {
        return ".csv";
    }
    
    @Override
    public String getFormatName() {
        return "CSV Schedule Table";
    }
    
    private void writeScheduleHeader(PrintWriter writer, List<Task> tasks) {
        LocalDateTime now = LocalDateTime.now();
        
        writer.println("ASTRONAUT DAILY SCHEDULE");
        writer.println("Generated on," + now.format(DATE_FORMAT) + " at " + now.format(DateTimeFormatter.ofPattern("HH:mm")));
        writer.println("Total Tasks," + tasks.size());
        writer.println(""); // Empty line separator
    }
    
    private void writeTableHeaders(PrintWriter writer) {
        StringBuilder header = new StringBuilder();
        header.append("Task No.").append(CSV_SEPARATOR);
        header.append("Task Description").append(CSV_SEPARATOR);
        header.append("Start Time").append(CSV_SEPARATOR);
        header.append("End Time").append(CSV_SEPARATOR);
        header.append("Duration (Hours)").append(CSV_SEPARATOR);
        header.append("Priority Level").append(CSV_SEPARATOR);
        header.append("Status").append(CSV_SEPARATOR);
        header.append("Notes");
        
        writer.println(header.toString());
    }
    
    private void writeScheduleData(PrintWriter writer, List<Task> tasks) {
        // Sort tasks by start time for chronological order
        List<Task> sortedTasks = tasks.stream()
            .sorted((t1, t2) -> t1.getStartTime().compareTo(t2.getStartTime()))
            .collect(java.util.stream.Collectors.toList());
        
        for (int i = 0; i < sortedTasks.size(); i++) {
            Task task = sortedTasks.get(i);
            writeScheduleRow(writer, task, i + 1);
        }
    }
    
    private void writeScheduleRow(PrintWriter writer, Task task, int taskNumber) {
        StringBuilder row = new StringBuilder();
        
        // Task Number
        row.append(taskNumber).append(CSV_SEPARATOR);
        
        // Task Description
        row.append(escapeCsv(task.getDescription())).append(CSV_SEPARATOR);
        
        // Start Time
        row.append(task.getFormattedStartTime()).append(CSV_SEPARATOR);
        
        // End Time  
        row.append(task.getFormattedEndTime()).append(CSV_SEPARATOR);
        
        // Duration in hours (more readable than minutes)
        double durationHours = task.getDurationMinutes() / 60.0;
        String durationStr = String.format("%.2f", durationHours);
        row.append(durationStr).append(CSV_SEPARATOR);
        
        // Priority Level
        row.append(task.getPriorityLevel().getDisplayName()).append(CSV_SEPARATOR);
        
        // Status
        String status = task.isCompleted() ? "Completed" : "Scheduled";
        row.append(status).append(CSV_SEPARATOR);
        
        // Notes (additional info)
        String notes = generateTaskNotes(task);
        row.append(escapeCsv(notes));
        
        writer.println(row.toString());
    }
    
    private String generateTaskNotes(Task task) {
        StringBuilder notes = new StringBuilder();
        
        // Add duration in minutes for reference
        notes.append(task.getDurationMinutes()).append(" min");
        
        // Add priority indicator
        if (task.getPriorityLevel() == PriorityLevel.CRITICAL || 
            task.getPriorityLevel() == PriorityLevel.HIGH) {
            notes.append(" | High Priority");
        }
        
        // Add completion status detail
        if (task.isCompleted()) {
            notes.append(" | Task Completed");
        } else {
            notes.append(" | Pending");
        }
        
        return notes.toString();
    }
    
    private void writeScheduleSummary(PrintWriter writer, List<Task> tasks) {
        writer.println(""); // Empty line separator
        writer.println("SCHEDULE SUMMARY");
        
        // Calculate statistics
        long totalTasks = tasks.size();
        long completedTasks = tasks.stream().filter(Task::isCompleted).count();
        long pendingTasks = totalTasks - completedTasks;
        
        double totalHours = tasks.stream()
            .mapToLong(Task::getDurationMinutes)
            .sum() / 60.0;
        
        // Priority breakdown
        long criticalTasks = tasks.stream().filter(t -> t.getPriorityLevel() == PriorityLevel.CRITICAL).count();
        long highTasks = tasks.stream().filter(t -> t.getPriorityLevel() == PriorityLevel.HIGH).count();
        long mediumTasks = tasks.stream().filter(t -> t.getPriorityLevel() == PriorityLevel.MEDIUM).count();
        long lowTasks = tasks.stream().filter(t -> t.getPriorityLevel() == PriorityLevel.LOW).count();
        
        // Write summary
        writer.println("Total Tasks," + totalTasks);
        writer.println("Completed Tasks," + completedTasks);
        writer.println("Pending Tasks," + pendingTasks);
        writer.println("Total Scheduled Hours," + String.format("%.2f", totalHours));
        writer.println("");
        writer.println("PRIORITY BREAKDOWN");
        writer.println("Critical Priority," + criticalTasks);
        writer.println("High Priority," + highTasks);
        writer.println("Medium Priority," + mediumTasks);
        writer.println("Low Priority," + lowTasks);
        
        // Schedule timing
        if (!tasks.isEmpty()) {
            List<Task> sortedTasks = tasks.stream()
                .sorted((t1, t2) -> t1.getStartTime().compareTo(t2.getStartTime()))
                .collect(java.util.stream.Collectors.toList());
            
            Task firstTask = sortedTasks.get(0);
            Task lastTask = sortedTasks.get(sortedTasks.size() - 1);
            
            writer.println("");
            writer.println("SCHEDULE TIMING");
            writer.println("First Task Starts," + firstTask.getFormattedStartTime());
            writer.println("Last Task Ends," + lastTask.getFormattedEndTime());
            
            // Calculate schedule span
            long scheduleSpanMinutes = java.time.Duration.between(
                firstTask.getStartTime(), 
                lastTask.getEndTime()
            ).toMinutes();
            double scheduleSpanHours = scheduleSpanMinutes / 60.0;
            writer.println("Schedule Span," + String.format("%.2f hours", scheduleSpanHours));
        }
    }
    
    private String escapeCsv(String value) {
        if (value == null) {
            return "";
        }
        
        // Escape quotes and wrap in quotes if necessary
        String escaped = value.replace(CSV_QUOTE, CSV_QUOTE + CSV_QUOTE);
        
        if (escaped.contains(CSV_SEPARATOR) || escaped.contains(CSV_QUOTE) || 
            escaped.contains("\n") || escaped.contains("\r")) {
            escaped = CSV_QUOTE + escaped + CSV_QUOTE;
        }
        
        return escaped;
    }
}
